# Костылева Виктория.

## Начало (Задача 0). ОК.

**Код** - ОК

**Тесты** - ОК

### Пожелания.

- Функция `extractField` работает со строками, содержащими 5 полей, строки в тестах содержат 3 поля. Оптимальное решение - работать с произвольным количеством полей, определяя их число по количеству разделителей.

## Тритсет (Задача 1). ОК.

**Код** - хорошо.

- [исправлено] `TritSet::operator&` возвращает ссылку на локальный объект (т.е. на объект, который будет удалён после выхода из метода).
Поскольку `operator&` возвращает новый объект, то типом возвращаемого значения должен быть просто `Tritset`. Аналогично	- `operator|`.

- [исправлено] Неправильная реализация `operator&=` и `operator|=`.
По логике, `&=` модифицирует левый аргумент (`this`), "конъюнктируя" с правым аргументом. По аналогии с:

```C++
int x = 5;
x += 3;
cout << x << endl; // 8
```

В принципе, `operator&=` (и аналоги) может быть реализован следующим образом:
```C++
// return *this & a; /* неправильно */
return *this = (*this & a);

```

- [исправлено] Обратить внимание на константность методов, передачу аргументов по ссылкам и типы возвращаемых значений, например:

```C++
TritSet operator&(TritSet b); // копирование b при передаче в метод
TritSet operator&=(const TritSet& a); // возврат нового объекта вместо ссылки на текущий
const TritSet& operator=(const TritSet& a); // возврат константной ссылки вместо неконстантной
int capacity(); // неконстантный метод
```

Подробнее про это можно посмотреть [здесь](/2016.cpp/seminar14/).

**Тесты** - отлично.

- [исправлено] добавить тесты на `operator&`, `operator&=`

## Робот (Задача 2). ОК.

**Код** - ОК.

- [ОК] Иерархия классов описана правильно.

- Синтаксис оператора чтения из потока немного другой, то есть там должно быть что-то вроде:
`in >> (*this); // чтение из in в текущий объект this`

Или вообще можно заменить на
`read(in);`

- [исправлено] реализация `operator>>(std::istream&, Field&)` и `operator<<(std::ostream&, Field const&)` описана в заголовочном файле и включается в несколько cpp файлов сразу.

- [исправлено] Удаление в дуструкторе адреса на поле `robot_pos` - является ошибкой.
Этот объект "локальный" в классе и удалится при удалении самого робота автоматически.
(кроме того, можно заметить, что этот объект не был создан при помощи new). 

-  [исправлено] [Хорошее пожелание] В классе Robot: вместо указателей `vector<Point>*` лучше использовать сами объекты `vector<Point>`.

**Тесты** - Добавлены.

**Пожелания**

- Заменить в шаблонном классе `Robot` типы полей: `Point robot_pos -> P robot_pos;`, `vector<tuple<Point, int> > points_to_go -> vector<tuple<P, M>> points_to_go;`, `Point go -> P go;`. Тогда робот сможет работать в том числе и со словарем.

- Вместо двух функций `stringstream& printPoint(Point a, stringstream& out)` и `void printPoint_c(Point a)` можно обойтись одним оператором `operator<<(ostream&, const Point &)`
