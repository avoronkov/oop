# Турчинович Михаил.

## Начало (Задача 0). ОК.

**Код** - ОК

**Тесты** - ОК

## Тритсет (Задача 1). ОК.

**Код** - в целом правильно, но есть замечания:

- `operator=` должен возврящять ссылку на "себя" - ОК.

- `#define SIZE` может различаться на разных платформах (должно быть что-то вроде `sizeof(unsigned int) * 8 / 4`) - ОК.

- Не определен `operator!=` для TritSet - ОК.

**Тесты** - ОК.

### Пожелания

- Вместо 1 и 0 для булевых констант лучше использовать `true` и `false`.

- Вместо
```C++
   if (*this == B)
    {   
        return 0;
    }   
    else
    {   
        return 1;
    }   
```
можно написать просто `return !(*this == B);`

## Робот (Задача 2). ОК.

**Код** - ОК.

- Немного неправильное использование исключений в методе `move`: исключение должно выбрасываться за пределы метода так, чтобы вызывающий этот метод мог обработать исключительную ситуацию. Примерно так:
```C++
unsigned int Cylinder::move(Point point)
{
	if ((point.x >= rows) || (point.y >= cols))
	{   
		throw BadMove();
	}   
	current_point = point;
	return calc_lenght_for_cylinder(point);
}

while (!finished) {
	try {
		cylinder->move(Point(x, y));
	}
	catch (BadMove e) {
		cerr << "Bad move... Let's try something else\n";
	}
}
```

- Больше к логике программы: BadMove это не только выход за пределы поля, но и переход в "несоседнюю" клетку.

- Пожелание по поводу исключений: удобно иметь возможность задавать сообщение об исключении. Например вида: `Bad move from point(1, 2) to Point(5,6)`.
В коде это могло бы выглядеть так (синтетический пример):
```C++
try {
	Point from(1, 2), to(5, 6);
	throw BadMove(from, to);
} catch (BadMove e) {
	cerr << e.what(); // shows message
}
```

- По организации кода: хорошим стилем считается иметь для каждого класса пару `.h + .cpp` файлов с именами, соответствующими имени класса, например, для класса `Cylinder` файлы `Cylinder.h` и `Cylinder.cpp` соответственно. Это позволяет быстрее ориентироваться в больших проектах.

- Подозрительный код: `fin >> (fin, *(current_surface));`

- В шаблонном роботе: немного неверно понята идея. На мой взгляд, робот должен иметь примерно следующую сигнатуру:
```C++
template<typename T, typename P>
class Robot {
public:
	Robot();
	vector<P> get_path(const T & topologie);
};
```
Далее в методе `get_path` робот оперирует с методами `move`, `lookup`.

*Тесты* - ОК.
