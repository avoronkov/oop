# Задача 2. Стековый калькулятор / интерпретатор.

[Оригинальное условие задачи для Java](https://docs.google.com/viewer?a=v&pid=sites&srcid=ZGVmYXVsdGRvbWFpbnxuZ3Vvb3B8Z3g6N2EyMTQ3NDgyYjY4NmU1NQ)

## Стековый язык программирования (Дополнительная задача)

Из стекового калькулятора можно сделать полноценный (полный по Тьюрингу)
язык программирования, если добавить в него циклы и условные переходы,
а также несколько специальных команд (функций):

- **DUP** - копировать верхний элемент на стеке (т.е. `a -> a a`)

- **SWAP** - поменять местами 2 верхних элемента (`a b -> b a`)

- **ROT** - взять третий элемент стека и поместить его наверх (`a b c -> b c a`)

- **DROP** - удалить верхний элемент со стека (`a -> `). Аналог команды POP.

Цикл можно обозначить следующей конструкцией: `[ <тело цикла> ]`.

Семантика цикла следующая: если на вершине стека находится true-значение (то есть не равное `0`), то верхний элемент удаляется со стека, выполняется тело цикла, затем снова проверяется условие цикла.

(Вместо `PUSH N` можно для простоты писать просто `N`).

Например, следующая программа распечатает числа от 5 до 1:

```
5 dup [ print 1 - dup ]
```

Программа для вычисления факториала числа 5:

```
5
1 swap dup [ dup rot * swap 1 - dup ] drop print
```

## (Вложенные циклы)

Для вычисления факториала можно обойтись без интерпретации вложенных циклов,
но правильная их реализация нужна.

## (!) Требования

- Программа должна считывать интерпретируемый код со стандартного потока ввода и писать результат на стандартный поток вывода.

- Команды должны считываться независимо от регистра (можно переводить токены в нижний регистр после считывания)

## Примеры.

### Сумма двух чисел
```
2 3 + print
```

Вывод: `5`

### Факториал числа 5
```
5
1 swap dup [ dup rot * swap 1 - dup ] drop print
```

Вывод: `120`

### Условный print
```
0 1 < [ 1 print 0 ]
```

Вывод: `1`

### Минимум двух чисел (1)
```
5 7
dup rot dup rot 1 rot rot  <
[ drop swap drop 0 0 ] 
[ drop 0 ] 
print
```

Вывод: `5`

### Минимум двух чисел (2)
```
7 5
dup rot dup rot 1 rot rot  <
[ drop swap drop 0 0 ] 
[ drop 0 ] 
print
```

Вывод: `5`

### Циклический print
```
5
dup [ print 1 - dup ]
```

Вывод:
```
5
4
3
2
1
```

### Вложенный циклический print
```
5
dup [ dup dup [ print 1 - dup ] drop 1 - dup ]
```
Вывод:
```
5
4
3
2
1
4
3
2
1
3
2
1
2
1
1
```
