# Семинар 2 (11.09.2015)

## Классы и объекты

Важно понимать (и уметь объяснять) разницу между понятиями "класс" и "объект".
Также важно понимать разницу между понятиями "метод класса" и "поле класса".

## Класс для работы со строками

Напишем свою собственную реализация класса "Строка".
Для того, чтобы не путать наш класс со строкой из стандартной библиотекой,
назовём наш класс `Str`.

Исходный код программы будет включать в себя три файла:
```
- str.h
- str.cpp
- main.cpp
```

Начнём с заголовочного файла`str.h`, который содержит объявление класса `Str`:
```C++
#pragma once

class Str { // A
public: // B
	Str(); // C
	Str(const char * s); // D
	~Str(); // E

private: // F
	char * data; // G
	int len;
};
```

Пояснения:

* _Строка A_: объявление нового класса с именем `Str`

* _Строка B_: модификатор доступа `public`: все методы, поля и конструкторы объявленные после этой строки являются "публичными", то есть доступными "снаружи" относительно класса

* _Строка C_: Объявление конструктора.
  Конструктор - это специальный метод  для инициализации ("конструирования") объекта - код конструктора будет вызван при создании объекта данного класса.
  Данный конструктор не принимает аргументов (и, как можно предположить, создаёт пустую строку).

* _Строка D_: Класс может иметь несколько конструкторов, различающихся набором аргументов.
  Данный конструктор создаёт строку на основе строки C (типа `const char *`)

* _Строка E_: Деструктор, то есть специальный метод для уничтожения объекта.
  Основная задача деструктора - "освободить" ресурсы, "захваченные" в процессе существования объекта (например, память, файловые дескрипторы и так далее).

* _Строка F_: модификатор доступа `private`: все поля, методы и конструкторы,
  объявленные после этой строки являются "приватными", то есть доступными только из других методов данного класса.

* _Строка G_: объявление полей класса. В данном случае это поле `data` типа `char *` и поле `len` типа `int`.
  `data` будет хранить содержимое строки, а `len` - её длину.

Далее, файл `str.cpp`, содержащий собственно код - __определения__ методов класса `Str`:
```C++
#include "str.h" // A

#include <cstring> // B
#include <cstdlib>

Str::Str() { // C
	data = nullptr; // D
	len = 0;
}

Str::Str(const char * s) { // E
	data = strdup(s); // F
	len = strlen(data);
}

Str::~Str() { // G
	free(data);
}
```

* _Строка A_: подключение заголовочного файла `str.h`.
  В C++ общепринятой практикой является создание для каждого класса в программе собственных заголовочного и исходного файла,
  имена которых совпадают с именем класса (или именем класса в нижнем регистре).
  Например, для класса `Str` мы создали два файла: `str.h` и `str.cpp`.
  Далее в первой строке cpp-файла необходимо подключить соответствующий h-файл - это будет признаком хорошего стиля :)

* _Строка B_: подключение библиотек языка C.
  Заметьте, что в C++ имена заголовочных файлов библиотек называются `cstring` и `cstdlib`, а не `string.h` и `stdlib.h`
  (хотя второй вариант тоже можно использовать)

* _Строка C_: Определение конструктора `Str` без аргументов.
  `Str` до знака `::` - это имя класса,
  `Str` после знака `::` - это имя конструктора,
  `()` - пустой список аргументов.

* _Строка D_: тело конструктора, в котором мы инициализируем поля класса значениями по умолчанию.
  `nullptr` - нулевой указатель, аналогичный `NULL` из C, но более безопасный (начиная с C++11).

* _Строка E_: определение второго конструктора, принимающего аргумент `char*`.

* _Строка F_: тело второго конструктора.
  Мы используем библиотечную функцию C `strdup` для копирования строки C.
  Важно отметить, что мы именно __копируем__ строку, а не сохраняем указатель.

* _Строка G_: определение деструктора.
  В отличие от конструктора, деструктор никогда не принимает аргументы.
  Внутри деструктора мы освобождаем память, выделенную в конструкторе, используя функцию `free`.

И наконец создадим файл `main.cpp`, в котором используем нашу новую строку:
```C++
#include "str.h"

void work() {
	Str x; // A
	Str y("hello world!"); // B
}

int main() {
	work();
	return 0;
}
```

Здесь в строке _A_ мы объявляем переменную `x` типа `Str`.
При этом вызовется конструктор без аргументов, который сделает `x` пустой строкой.
В строке _B_ объявляется переменная `y` типа `Str`, при этом вызовется второй конструктор
с аргументом `"hello world!"` и `y` будет содержать копию строки `"hello world!"`
При выходе из функции переменные `x` и `y` перестанут существовать, и будут вызваны
деструкторы `x` и `y`.


*Продолжение следует...*
