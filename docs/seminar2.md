# Семинар 2 (11.09.2015)

## Классы и объекты

Важно понимать (и уметь объяснять) разницу между понятиями "класс" и "объект".
Также важно понимать разницу между понятиями "метод класса" и "поле класса".

## Класс для работы со строками

Напишем свою собственную реализация класса "Строка".
Для того, чтобы не путать наш класс со строкой из стандартной библиотекой,
назовём наш класс `Str`.

Исходный код программы будет включать в себя три файла:
```
- str.h
- str.cpp
- main.cpp
```

Начнём с заголовочного файла`str.h`, который содержит объявление класса `Str`:
```C++
#pragma once

class Str { // A
public: // B
	Str(); // C
	Str(const char * s); // D
	~Str(); // E

private: // F
	char * data; // G
	int len;
};
```

Пояснения:

* _Строка A_: объявление нового класса с именем `Str`

* _Строка B_: модификатор доступа `public`: все методы, поля и конструкторы объявленные после этой строки являются "публичными", то есть доступными "снаружи" относительно класса

* _Строка C_: Объявление конструктора.
  Конструктор - это специальный метод  для инициализации ("конструирования") объекта - код конструктора будет вызван при создании объекта данного класса.
  Данный конструктор не принимает аргументов (и, как можно предположить, создаёт пустую строку).

* _Строка D_: Класс может иметь несколько конструкторов, различающихся набором аргументов.
  Данный конструктор создаёт строку на основе строки C (типа `const char *`)

* _Строка E_: Деструктор, то есть специальный метод для уничтожения объекта.
  Основная задача деструктора - "освободить" ресурсы, "захваченные" в процессе существования объекта (например, память, файловые дескрипторы и так далее).

* _Строка F_: модификатор доступа `private`: все поля, методы и конструкторы,
  объявленные после этой строки являются "приватными", то есть доступными только из других методов данного класса.

* _Строка G_: объявление полей класса. В данном случае это поле `data` типа `char *` и поле `len` типа `int`.
  `data` будет хранить содержимое строки, а `len` - её длину.

Далее, файл `str.cpp`, содержащий собственно код - __определения__ методов класса `Str`:
```C++
#include "str.h" // A

#include <cstring> // B
#include <cstdlib>

Str::Str() { // C
	data = nullptr; // D
	len = 0;
}

Str::Str(const char * s) { // E
	data = strdup(s); // F
	len = strlen(data);
}

Str::~Str() { // G
	free(data);
}
```

* _Строка A_: подключение заголовочного файла `str.h`.
  В C++ общепринятой практикой является создание для каждого класса в программе собственных заголовочного и исходного файла,
  имена которых совпадают с именем класса (или именем класса в нижнем регистре).
  Например, для класса `Str` мы создали два файла: `str.h` и `str.cpp`.
  Далее в первой строке cpp-файла необходимо подключить соответствующий h-файл - это будет признаком хорошего стиля :)

* _Строка B_: подключение библиотек языка C.
  Заметьте, что в C++ имена заголовочных файлов библиотек называются `cstring` и `cstdlib`, а не `string.h` и `stdlib.h`
  (хотя второй вариант тоже можно использовать)

* _Строка C_: Определение конструктора `Str` без аргументов.
  `Str` до знака `::` - это имя класса,
  `Str` после знака `::` - это имя конструктора,
  `()` - пустой список аргументов.

* _Строка D_: тело конструктора, в котором мы инициализируем поля класса значениями по умолчанию.
  `nullptr` - нулевой указатель, аналогичный `NULL` из C, но более безопасный (начиная с C++11).

* _Строка E_: определение второго конструктора, принимающего аргумент `char*`.

* _Строка F_: тело второго конструктора.
  Мы используем библиотечную функцию C `strdup` для копирования строки C.
  Важно отметить, что мы именно __копируем__ строку, а не сохраняем указатель.

* _Строка G_: определение деструктора.
  В отличие от конструктора, деструктор никогда не принимает аргументы.
  Внутри деструктора мы освобождаем память, выделенную в конструкторе, используя функцию `free`.

И наконец создадим файл `main.cpp`, в котором используем нашу новую строку:
```C++
#include "str.h"

void work() {
	Str x; // A
	Str y("hello world!"); // B
}

int main() {
	work();
	return 0;
}
```

Здесь в строке _A_ мы объявляем переменную `x` типа `Str`.
При этом вызовется конструктор без аргументов, который сделает `x` пустой строкой.
В строке _B_ объявляется переменная `y` типа `Str`, при этом вызовется второй конструктор
с аргументом `"hello world!"` и `y` будет содержать копию строки `"hello world!"`
При выходе из функции переменные `x` и `y` перестанут существовать, и будут вызваны
деструкторы `x` и `y`.

## Методы класса

Нетрудно заметить, что в текущем виде класс `Str` не позволяет сделать что-нибудь действительно полезное,
потому чо в нём пока нет _методов_.
Самое время добавить немного методов. В заголовочный файл добавим следующее:
```C++
#pragma once

class Str {
public:
	Str();
	Str(const char * s);
	~Str();

	int size() const; // H
	char get(int index) const; // I
	void set(int index, char c); // J

private:
	char * data;
	int len;
};
```

Здесь мы объявили три метода: `size`, `get` и `set`.
* _H_: декларация методов похожа на декларацию функций: возвращаемое значение (`int`),
  имя метода (`size`), список аргументов (в данном случае пустой - `()`).
  Стоит отметить наличие модификатора `const`, который говорит о том, что метод является _константным_,
  то есть не изменяет состояние объекта (то есть состояние полей объекта), для которого он вызван.
  Метод `size()` возвращает длину строки.

* _I_: метод `get(...)`, который возвращает символ строки в позиции `index`.

* _J_: метод `set(...)`, который устанавливает символ `c` в позиции `index`.
  Так как метод не является константным, модификатора `const` у него нет.

Теперь определим наши новые методы в `str.cpp`:
```C++
// ...

int Str::size() const { // H
	return len;
}

char Str::get(int index) const {
	if (index >= 0 && index < len) {
		return data[index];
	}
	return '\0'; // J
}

void Str::set(int index, char c) {
	if (index >= 0 && index < len) {
		data[index] = c;
	}
}

```

* _H_: определения методов похожи на определения конструкторов (и на определения обычных функций):
    * `int` - возвращаемое значение,
	* `Str` - имя класса,
	* `size` - имя метода,
	* `()` - список аргументов
	* модификатор `const` обязателен, если он присутствовал в _объявлении_ метода (в h-файле).
	  Метод с `const` и метод без `const` - это два разных метода.

* _J_: вообще попытка получить символ за границами строки в методе `get` является ошибкой,
  но пока мы просто вернём нулевой символ (`'\0'`). С методом `set` - аналогично.

Стоит отметить, что так же, как и в случае с конктрукторами, класс может содержать несколько методов
с одинаковыми именами, но разными наборами аргументов.

Воспользуемся нашими новыми методами. В `main.cpp`:
```C++
#include <iostream>
#include "str.h"

int main() {
	Str x("hello world!");
	x.set(0, 'H');
	for (int i = 0; i < x.size(); i++) {
		std::cout << x.get(i);
	}
	std::cout << std::endl;
}
```

Рекомендую ознакомиться с методами класса `str::string` из стандартной библиотеки,
документацию можно посмотреть [здесь](http://www.cplusplus.com/reference/string/string/).

## Оператор вывода в поток

Одной из особенностей C++ при работе с вводом/выводом является использование потоков.
Определим оператор вывода в поток для класса `Str`. 
Для этого нам понадобится вспомогательный метод `put`,
который будет записывать объект в поток.
```C++
#pragma once

#include <iostream> // K

class Str {
public:
	Str();
	Str(const char * s);
	~Str();

	int size() const;
	char get(int index) const;
	void set(int index, char c);

	void put(std::ostream & out) const; // L

private:
	char * data;
	int len;
};

std::ostream & operator<<(std::ostream & out, const Str & str); // M
```

* _K_: подключаем `iostream` для работы с потоками.

* _L_: вспомогательный метод `put`

* _K_: объявление оператора записи в поток.
  Следует отметить, что поток `out` передаётся по ссылке,
  а строка `str` по _константной_ ссылке. (Почему?)
  Также следует отметить, что `operator<<` является в данном случае
  обычной функцией, а не методом класса `Str`.

Добавим определения в `str.cpp`:
```C++
// ...
void Str::put(std::ostream & out) const {
	out << '"' << data << '"';
}


std::ostream & operator<<(std::ostream & out, const Str & str) {
	str.put(out);
	return out;
}
```

Здесь всё достаточно просто.
Хотя можно задать вопрос: зачем понадобился дополнительный метод `put`?

_Примечание_: можно обойтись без вспомогательного метода,
если воспользоваться помощью _друзей_ ([friendship](http://www.cplusplus.com/doc/tutorial/inheritance/)),
но этот метод имеет свои недостатки, поэтому (пока) имеет смысл от него воздержаться.

Собственно, теперь мы можем использовать потоки вывода вместе с нашим классом `Str`:
```C++
int main() {
	Str x("hello world!");
	std::cout << x << std::endl;
}

```
*Продолжение следует...*
