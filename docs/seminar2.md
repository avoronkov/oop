# Семинар 2 (11.09.2015)

## Классы и объекты

Важно понимать (и уметь объяснять) разницу между понятиями "класс" и "объект".
Также важно понимать разницу между понятиями "метод класса" и "поле класса".

## Класс для работы со строками

Напишем свою собственную реализация класса "Строка".
Для того, чтобы не путать наш класс со строкой из стандартной библиотекой,
назовём наш класс `Str`.

Исходный код программы будет включать в себя три файла:
```
- str.h
- str.cpp
- main.cpp
```

Начнём с заголовочного файла`str.h`, который содержит объявление класса `Str`:
```C++
#pragma once

class Str { // A
public: // B
	Str(); // C
	Str(const char * s); // D
	~Str(); // E

private: // F
	char * data; // G
	int len;
};
```

Пояснения:

* _Строка A_: объявление нового класса с именем `Str`

* _Строка B_: модификатор доступа `public`: все методы, поля и конструкторы объявленные после этой строки являются "публичными", то есть доступными "снаружи" относительно класса

* _Строка C_: Объявление конструктора.
  Конструктор - это специальный метод  для инициализации ("конструирования") объекта - код конструктора будет вызван при создании объекта данного класса.
  Данный конструктор не принимает аргументов (и, как можно предположить, создаёт пустую строку).

* _Строка D_: Класс может иметь несколько конструкторов, различающихся набором аргументов.
  Данный конструктор создаёт строку на основе строки C (типа `const char *`)

* _Строка E_: Деструктор, то есть специальный метод для уничтожения объекта.
  Основная задача деструктора - "освободить" ресурсы, "захваченные" в процессе существования объекта (например, память, файловые дескрипторы и так далее).

* _Строка F_: модификатор доступа `private`: все поля, методы и конструкторы,
  объявленные после этой строки являются "приватными", то есть доступными только из других методов данного класса.

* _Строка G_: объявление полей класса. В данном случае это поле `data` типа `char *` и поле `len` типа `int`.
  `data` будет хранить содержимое строки, а `len` - её длину.

Далее, файл `str.cpp`, содержащий собственно код - __определения__ методов класса `Str`:
```C++
#include "str.h" // A

#include <cstring> // B
#include <cstdlib>

Str::Str() { // C
	data = nullptr; // D
	len = 0;
}

Str::Str(const char * s) { // E
	data = strdup(s); // F
	len = strlen(data);
}

Str::~Str() { // G
	free(data);
}
```

* _Строка A_: подключение заголовочного файла `str.h`.
  В C++ общепринятой практикой является создание для каждого класса в программе собственных заголовочного и исходного файла,
  имена которых совпадают с именем класса (или именем класса в нижнем регистре).
  Например, для класса `Str` мы создали два файла: `str.h` и `str.cpp`.
  Далее в первой строке cpp-файла необходимо подключить соответствующий h-файл - это будет признаком хорошего стиля :)

* _Строка B_: подключение библиотек языка C.
  Заметьте, что в C++ имена заголовочных файлов библиотек называются `cstring` и `cstdlib`, а не `string.h` и `stdlib.h`
  (хотя второй вариант тоже можно использовать)

* _Строка C_: Определение конструктора `Str` без аргументов.
  `Str` до знака `::` - это имя класса,
  `Str` после знака `::` - это имя конструктора,
  `()` - пустой список аргументов.

* _Строка D_: тело конструктора, в котором мы инициализируем поля класса значениями по умолчанию.
  `nullptr` - нулевой указатель, аналогичный `NULL` из C, но более безопасный (начиная с C++11).

* _Строка E_: определение второго конструктора, принимающего аргумент `char*`.

* _Строка F_: тело второго конструктора.
  Мы используем библиотечную функцию C `strdup` для копирования строки C.
  Важно отметить, что мы именно __копируем__ строку, а не сохраняем указатель.

* _Строка G_: определение деструктора.
  В отличие от конструктора, деструктор никогда не принимает аргументы.
  Внутри деструктора мы освобождаем память, выделенную в конструкторе, используя функцию `free`.

И наконец создадим файл `main.cpp`, в котором используем нашу новую строку:
```C++
#include "str.h"

void work() {
	Str x; // A
	Str y("hello world!"); // B
}

int main() {
	work();
	return 0;
}
```

Здесь в строке _A_ мы объявляем переменную `x` типа `Str`.
При этом вызовется конструктор без аргументов, который сделает `x` пустой строкой.
В строке _B_ объявляется переменная `y` типа `Str`, при этом вызовется второй конструктор
с аргументом `"hello world!"` и `y` будет содержать копию строки `"hello world!"`
При выходе из функции переменные `x` и `y` перестанут существовать, и будут вызваны
деструкторы `x` и `y`.

## Методы класса

Нетрудно заметить, что в текущем виде класс `Str` не позволяет сделать что-нибудь действительно полезное,
потому чо в нём пока нет _методов_.
Самое время добавить немного методов. В заголовочный файл добавим следующее:
```C++
#pragma once

class Str {
public:
	Str();
	Str(const char * s);
	~Str();

	int size() const; // H
	char get(int index) const; // I
	void set(int index, char c); // J

private:
	char * data;
	int len;
};
```

Здесь мы объявили три метода: `size`, `get` и `set`.
* _H_: декларация методов похожа на декларацию функций: возвращаемое значение (`int`),
  имя метода (`size`), список аргументов (в данном случае пустой - `()`).
  Стоит отметить наличие модификатора `const`, который говорит о том, что метод является _константным_,
  то есть не изменяет состояние объекта (то есть состояние полей объекта), для которого он вызван.
  Метод `size()` возвращает длину строки.

* _I_: метод `get(...)`, который возвращает символ строки в позиции `index`.

* _J_: метод `set(...)`, который устанавливает символ `c` в позиции `index`.
  Так как метод не является константным, модификатора `const` у него нет.

Теперь определим наши новые методы в `str.cpp`:
```C++
// ...

int Str::size() const { // H
	return len;
}

char Str::get(int index) const {
	if (index >= 0 && index < len) {
		return data[index];
	}
	return '\0'; // J
}

void Str::set(int index, char c) {
	if (index >= 0 && index < len) {
		data[index] = c;
	}
}

```

* _H_: определения методов похожи на определения конструкторов (и на определения обычных функций):
    * `int` - возвращаемое значение,
	* `Str` - имя класса,
	* `size` - имя метода,
	* `()` - список аргументов
	* модификатор `const` обязателен, если он присутствовал в _объявлении_ метода (в h-файле).
	  Метод с `const` и метод без `const` - это два разных метода.

* _J_: вообще попытка получить символ за границами строки в методе `get` является ошибкой,
  но пока мы просто вернём нулевой символ (`'\0'`). С методом `set` - аналогично.

Стоит отметить, что так же, как и в случае с конктрукторами, класс может содержать несколько методов
с одинаковыми именами, но разными наборами аргументов.

Воспользуемся нашими новыми методами. В `main.cpp`:
```C++
#include <iostream>
#include "str.h"

int main() {
	Str x("hello world!");
	x.set(0, 'H');
	for (int i = 0; i < x.size(); i++) {
		std::cout << x.get(i);
	}
	std::cout << std::endl;
}
```

Рекомендую ознакомиться с методами класса `str::string` из стандартной библиотеки,
документацию можно посмотреть [здесь](http://www.cplusplus.com/reference/string/string/).

## Оператор вывода в поток

Одной из особенностей C++ при работе с вводом/выводом является использование потоков.
Определим оператор вывода в поток для класса `Str`. 
Для этого нам понадобится вспомогательный метод `put`,
который будет записывать объект в поток.
```C++
#pragma once

#include <iostream> // K

class Str {
public:
	Str();
	Str(const char * s);
	~Str();

	int size() const;
	char get(int index) const;
	void set(int index, char c);

	void put(std::ostream & out) const; // L

private:
	char * data;
	int len;
};

std::ostream & operator<<(std::ostream & out, const Str & str); // M
```

* _K_: подключаем `iostream` для работы с потоками.

* _L_: вспомогательный метод `put`

* _K_: объявление оператора записи в поток.
  Следует отметить, что поток `out` передаётся по ссылке,
  а строка `str` по _константной_ ссылке. (Почему?)
  Также следует отметить, что `operator<<` является в данном случае
  обычной функцией, а не методом класса `Str`.

Добавим определения в `str.cpp`:
```C++
// ...
void Str::put(std::ostream & out) const {
	out << '"' << data << '"';
}


std::ostream & operator<<(std::ostream & out, const Str & str) {
	str.put(out);
	return out;
}
```

Здесь всё достаточно просто.
Хотя можно задать вопрос: зачем понадобился дополнительный метод `put`?

_Примечание_: можно обойтись без вспомогательного метода,
если воспользоваться помощью _друзей_ ([friendship](http://www.cplusplus.com/doc/tutorial/inheritance/)),
но этот метод имеет свои недостатки, поэтому (пока) имеет смысл от него воздержаться.

Собственно, теперь мы можем использовать потоки вывода вместе с нашим классом `Str`:
```C++
int main() {
	Str x("hello world!");
	std::cout << x << std::endl;
}

```

## Итераторы

Если посмотреть на методы [std::string](http://www.cplusplus.com/reference/string/string/), то можно обнаружить
методы [begin](http://www.cplusplus.com/reference/string/string/begin/) и [end](http://www.cplusplus.com/reference/string/string/end/),
которые возвращают объекты класса `std::string::iterator`.
Вообще, концепция _итераторов_ - специальных объектов, позволяющих получить доступ к некоторому элементу коллекции
(а также к соседних элементам) - широко распространена в стандартной библиотеке C++.
В документации можно найти пример типичного использования итераторов:
```C++
std::string str ("Test string");
for ( std::string::iterator it=str.begin(); it!=str.end(); ++it)
	std::cout << *it;
std::cout << '\n';
```
Как нетрудно догадаться, здесь последовательно распечатываются символы строки.

Попробуем реализовать простейший итератор для класса `Str`. В заголовочный файл добавим:
```C++
class Str {
public:
	// ...
    class iterator {
    public:
        iterator(char * _data, int _len, int _pos);
		iterator(const iterator & it) = default;
        ~iterator() = default;

        iterator & operator+=(int i); 
		iterator operator+(int i) const;
        iterator & operator++();
        iterator operator++(int);

        char & operator*();
        char * operator->();
    private:
        char * str_data;
        int str_len;
        int position;
    };  

    iterator begin();
    iterator end();
private:
    char * data;
    int len;
};
```

Как видно, итератор будет указывать на некоторую позицию в строке. Реализация:
```C++
Str::iterator::iterator(char * _data, int _len, int _pos) :
    str_data(_data),
    str_len(_len),
    position(_pos)
{
        
}

Str::iterator & Str::iterator::operator+=(int i) {
    this->position += i;
    return *this;
}

Str::iterator & Str::iterator::operator++() {
    (*this) += 1;
    return *this;
}

Str::iterator Str::iterator::operator++(int) {
    Str::iterator it(*this);
    (*this) += 1;
    return it; 
}

char & Str::iterator::operator*() {
    return str_data[position];
}

char * Str::iterator::operator->() {
    return str_data + position;
}

Str::iterator Str::begin() {
    return Str::iterator(data, len, 0);
}

Str::iterator Str::end() {
    return Str::iterator(data, len, len);
}
```

Комментарии:
* В конструкторе `Str::iterator::iterator` показана форма инициализации полей до исполнения тела конструктора
  (выглядит более лаконично и может использоваться для инициализации константных полей)

* `this` - это указатель на самого себя. Как можно догадаться, имеет тип `Str*`.
  Операторы `+=` и префиксный оператор `++` возвращают ссылку на самого себя.

* `operator++(int)` - это постфиксный оператор `++`. Вспомните разницу между `++i` и `i++`.
  Постфиксный итератор делает инкремент внутри себя, но возвращает копию старого итератора.

* оператор `*` возвращает ссылку на элемент строки. В данном случае синтаксис аналогичен разыменованию указателей в C.

Теперь воспользуемся нашим итератором:
```C++
int main() {
	Str str("hello world!");
    for (Str::iterator it = str.begin(); it != str.end(); ++it) {
        std::cout << *it;
    }   
    std::cout << std::endl;
}
```
Компилируем и ...
```
error: no match for ‘operator!=’ (operand types are ‘Str::iterator’ and ‘Str::iterator’)
  for (Str::iterator it = str.begin(); it != str.end(); ++it) {
                                          ^
```

Мы забыли про операторы `==` и `!=` для итераторов. Эти операторы должны иметь следующую сигнатуру:
```C++
class iterator {
	// ...
	bool operator==(const iterator & it) const;
	bool operator!=(const iterator & it) const;
};
```
Как правило, в таких случаях реализуют один оператор, а второй реализуют через отрицание первого.
Если сделать всё правильно, то наш код скомпилируется и выведет `hello world!`.

А теперь - бонус! Для класса, имеющего итераторы начиная с C++11 можно написать следующий код:
```C++
int main() {
	Str str("hello world!");
    for (char c : str) {
        std::cout << c;
    }   
    std::cout << std::endl;
}
```
Этот код аналогичен приведенному выше "итерированию" коллекций через итераторы, только намного проще :)

*Продолжение следует...*
