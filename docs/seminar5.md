# Семинар 5 (02.10.2015)

## Типичные ошибки

Обращайте внимание не только на ошибки, выдаваемые компилятором, но и на **предупреждения (warnings)**.
Поищите, как в вашей рабочей среде настроить компилятор так, чтобы он выдавал предупреждения.
Например, при использовании *gcc* (`g++`) под Linux или при использовании *mingw* в Windows,
вывод всех предупреждений включается опцией `-Wall`:
```
g++ -std=c++14 -Wall source1.cpp source2.cpp ...
```

Многое из того, что сообщает компилятор указывает на логические ошибки в коде.
Например:
```
В функции-члене «LinkedList::iterator& LinkedList::iterator::operator++()»:
предупреждение: присваивание, используемое как логическое выражение, рекомендуется  [-Wparentheses]
     if (this->element = NULL)
                             ^
```
Скорее всего, **вместо присваивания** (`=`) в этой строке подразумевалось **сравнение** (`==`).
В таком виде блок кода идущий после `if (...)` никогда не будет выполнен.

Ещё пример:
```
В функции-члене «LinkedList::iterator LinkedList::iterator::operator++(int)»:
предупреждение: control reaches end of non-void function [-Wreturn-type]
 }
 ^
```
**Нет возвращаемого значения** при выходе из не-void функции,
что будет делать программа при вызове этого метода скорее всего неопределено.

**Не используйте функцию `memcpy`** для копирования объектов, для этого есть оператор присваивания (`operator=`)
и возможность его перегрузить.

При **копировании итератора** (с использованием констуктора `iterator(const iterator &)` или оператора присваивания
`iterator & operator=(const iterator&)`) не нужно копировать узел (_Node_), на который указывает итератор.
Например, если `iterator` содержит поля:
```
class iterator {
	Node * node;
}
```
то при копировании итератора нужно просто скопировать указатель:
```
iterator(const iterator & other): node(other.node) {
}

iterator & operator=(const iterator & other) {
	this->node = other.node;
}
```
Кстати, в точности то же самое сделает `default`:
```
iterator(const iterator & other): node(other.node) = default;
iterator & operator=(const iterator & other) = default;
```
Объяснение достаточно простое: итератор не владеет "узлом" с данными, на который он указывает.
Данными владеет класс `LinkedList`.
По этой же причине при деструктор итератора (`~iterator()`) не должен удалять "узел".

**Операторы `+` и `+=`**. Оператор `+` не изменяет содержимое ни одного из двух аргументов
и возвращает новый объект. Пример для чисел:
```
int x = 10;
int y = 15;
int z = x + y;
// сожержимое x и y не изменилось. z содержит новое значение.
```
Оператор `+=` изменяет содержимое первого аргумента, но не трогает второе:
```
int x = 10;
int y = 15
x += y;
// x содержит новое значение, значение y не изменилось.
```

Теперь к классам. Обратите внимание на сигнатуру операторов:
```
	List operator+(const List & other) const;
	List& operator+=(const List & other);
```
`operator+` возвращает `List`, то есть новый объект, `operator+=` возвращает ссылку `List&`.
Семантически это "ссылка на самого себя".
Что это значит? Это значит, то можно написать следующий код:
```
string x = "one";
(x += "two") += "three";
cout << x << endl;
// резутьтат: onetwothree
```
Если бы `operator+=` возвращал новый объект (`List`) вместо ссылки (`List&`),
то при вызове `+= "three"` менялось содержимое не `x`, а этого нового объекта и результат был бы `onetwo`.

Можно определить оператор `+` через `+=` и конструктор копирования:
```
List& operator+=(const List & other) {
	for (List::iterator it = other.begin(); it != other.end(); ++it) {
		this->push_back(*it);
	}
	return *this;
}

List operator+(const List & other) const {
	List result(*this); // создаём копию "этого" списка
	result += other; // добавляем к копии "другой" список
	return result; // возвращаем результат
}
```

**Сравнение итераторов.** В коде часто встречается конструкция `it != list.end()`.
Как правильно сравнить два итератора?
Во-первых, нужно помнить, что итераторы можно копировать.
Во-вторых, что значит "два итератора равны"?
В случае со списком это означает, что два итератора указывают на один и тот-же узел.
Как понять, что итераторы указывают на один и тот же узел?
Использовать "хитрый хак" - сравнить два указателя :)
```
bool operator==(const iterator & other) const {
	return this->node == other.node;
}
bool operator!=(const iterator & other) const {
	return !((*this) == other);
}
```

_Продолжение следует_

## Пожелания

**Структуры с стиле C**. Вместо
```C++
typedef struct _MyStruct {
	int some_field;
} MyStruct;
```
можно писать просто
```C++
struct MyStruct {
	int some_field;
};
```
Поскольку ключевое слово `struct` так же, как слово `class`, определяет класс, но с доступом `public` к членам класса по-умолчанию, последняя запись аналогична:
```C++
class MyStruct {
public:
	int some_field;
};
```

