<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>Seminar 5 - OOP Practice Docs</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">OOP Practice Docs</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Home</a>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Seminars C++ <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../seminar1/">Seminar 1</a>
</li>

                        
                            
<li >
    <a href="../seminar2/">Seminar 2</a>
</li>

                        
                            
<li >
    <a href="../seminar3/">Seminar 3</a>
</li>

                        
                            
<li class="active">
    <a href="./">Seminar 5</a>
</li>

                        
                            
<li >
    <a href="../seminar6/">Seminar 6</a>
</li>

                        
                            
<li >
    <a href="../seminar11/">Seminar 11</a>
</li>

                        
                            
<li >
    <a href="../seminar14/">Seminar 14</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Extras <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../assembla/">Acceptance</a>
</li>

                        
                            
<li >
    <a href="../using-namespaces/">Using namespaces</a>
</li>

                        
                            
<li >
    <a href="../cmake/">CMake</a>
</li>

                        
                            
<li >
    <a href="../using-subversion/">Svn</a>
</li>

                        
                            
<li >
    <a href="../using-googletest/">GoogleTest</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Acceptance <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../java-acceptance/">Java</a>
</li>

                        
                            
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">Java Task1</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../java_task1/ospanov/">Ospanov</a>
</li>

        
    </ul>
  </li>

                        
                            
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">Java Task2</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../java_task2_results/amikishieva_task2/">Amikishieva</a>
</li>

        
            
<li >
    <a href="../java_task2_results/kambalina_task2/">Kambalina</a>
</li>

        
            
<li >
    <a href="../java_task2_results/matveev_task2/">Matveev</a>
</li>

        
            
<li >
    <a href="../java_task2_results/shachenko_task2/">Shachenko</a>
</li>

        
            
<li >
    <a href="../java_task2_results/dudaev_task2/">Dudaev</a>
</li>

        
    </ul>
  </li>

                        
                            
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">Java Task3</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../java_task3/katchik/">Katchik</a>
</li>

        
            
<li >
    <a href="../java_task3/svischev/">Svischev</a>
</li>

        
    </ul>
  </li>

                        
                            
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">Java Task4</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../java_task4/matveev/">Matveev</a>
</li>

        
    </ul>
  </li>

                        
                            
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">Java Task5</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../java_task5/matveev/">Matveev</a>
</li>

        
    </ul>
  </li>

                        
                            
<li >
    <a href="../tasks-acceptance/">C++</a>
</li>

                        
                            
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">C++ Task1</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../task1_test_results/amikishieva_task1_test_results/">Amikishieva</a>
</li>

        
            
<li >
    <a href="../task1_test_results/demidov_task1_test_results/">Demidov</a>
</li>

        
            
<li >
    <a href="../task1_test_results/dudaev_task1_test_results/">Dudaev</a>
</li>

        
            
<li >
    <a href="../task1_test_results/kambalina_task1_test_results/">Kambalina</a>
</li>

        
            
<li >
    <a href="../task1_test_results/shachenko_task1_test_results/">Shachenko</a>
</li>

        
    </ul>
  </li>

                        
                            
<li >
    <a href="../final-tasks/">Final C++ tasks</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="../seminar3/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../seminar6/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#5-02102015">Семинар 5 (02.10.2015)</a></li>
        
            <li><a href="#07102015">! Обновление (07.10.2015)</a></li>
        
            <li><a href="#_1">Типичные ошибки</a></li>
        
            <li><a href="#_2">Пожелания</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="5-02102015">Семинар 5 (02.10.2015)</h1>
<h2 id="07102015">! Обновление (07.10.2015)</h2>
<p>Обратите внимание на <a href="../tasks-acceptance">результаты компиляции и запуска тестов</a></p>
<h2 id="_1">Типичные ошибки</h2>
<p>Обращайте внимание не только на ошибки, выдаваемые компилятором, но и на <strong>предупреждения (warnings)</strong>.
Поищите, как в вашей рабочей среде настроить компилятор так, чтобы он выдавал предупреждения.
Например, при использовании <em>gcc</em> (<code>g++</code>) под Linux или при использовании <em>mingw</em> в Windows,
вывод всех предупреждений включается опцией <code>-Wall</code>:</p>
<pre><code>g++ -std=c++14 -Wall source1.cpp source2.cpp ...
</code></pre>

<p>Многое из того, что сообщает компилятор указывает на логические ошибки в коде.
Например:</p>
<pre><code>В функции-члене «LinkedList::iterator&amp; LinkedList::iterator::operator++()»:
предупреждение: присваивание, используемое как логическое выражение, рекомендуется  [-Wparentheses]
     if (this-&gt;element = NULL)
                             ^
</code></pre>

<p>Скорее всего, <strong>вместо присваивания</strong> (<code>=</code>) в этой строке подразумевалось <strong>сравнение</strong> (<code>==</code>).
В таком виде блок кода идущий после <code>if (...)</code> никогда не будет выполнен.</p>
<p>Ещё пример:</p>
<pre><code>В функции-члене «LinkedList::iterator LinkedList::iterator::operator++(int)»:
предупреждение: control reaches end of non-void function [-Wreturn-type]
 }
 ^
</code></pre>

<p><strong>Нет возвращаемого значения</strong> при выходе из не-void функции,
что будет делать программа при вызове этого метода скорее всего неопределено.</p>
<p><strong>Не используйте функцию <code>memcpy</code></strong> для копирования объектов, для этого есть оператор присваивания (<code>operator=</code>)
и возможность его перегрузить.</p>
<p>При <strong>копировании итератора</strong> (с использованием констуктора <code>iterator(const iterator &amp;)</code> или оператора присваивания
<code>iterator &amp; operator=(const iterator&amp;)</code>) не нужно копировать узел (<em>Node</em>), на который указывает итератор.
Например, если <code>iterator</code> содержит поля:</p>
<pre><code>class iterator {
    Node * node;
}
</code></pre>

<p>то при копировании итератора нужно просто скопировать указатель:</p>
<pre><code>iterator(const iterator &amp; other): node(other.node) {
}

iterator &amp; operator=(const iterator &amp; other) {
    this-&gt;node = other.node;
}
</code></pre>

<p>Кстати, в точности то же самое сделает <code>default</code>:</p>
<pre><code>iterator(const iterator &amp; other): node(other.node) = default;
iterator &amp; operator=(const iterator &amp; other) = default;
</code></pre>

<p>Объяснение достаточно простое: итератор не владеет "узлом" с данными, на который он указывает.
Данными владеет класс <code>LinkedList</code>.
По этой же причине при деструктор итератора (<code>~iterator()</code>) не должен удалять "узел".</p>
<p><strong>Операторы <code>+</code> и <code>+=</code></strong>. Оператор <code>+</code> не изменяет содержимое ни одного из двух аргументов
и возвращает новый объект. Пример для чисел:</p>
<pre><code>int x = 10;
int y = 15;
int z = x + y;
// сожержимое x и y не изменилось. z содержит новое значение.
</code></pre>

<p>Оператор <code>+=</code> изменяет содержимое первого аргумента, но не трогает второе:</p>
<pre><code>int x = 10;
int y = 15
x += y;
// x содержит новое значение, значение y не изменилось.
</code></pre>

<p>Теперь к классам. Обратите внимание на сигнатуру операторов:</p>
<pre><code>    List operator+(const List &amp; other) const;
    List&amp; operator+=(const List &amp; other);
</code></pre>

<p><code>operator+</code> возвращает <code>List</code>, то есть новый объект, <code>operator+=</code> возвращает ссылку <code>List&amp;</code>.
Семантически это "ссылка на самого себя".
Что это значит? Это значит, то можно написать следующий код:</p>
<pre><code>string x = &quot;one&quot;;
(x += &quot;two&quot;) += &quot;three&quot;;
cout &lt;&lt; x &lt;&lt; endl;
// резутьтат: onetwothree
</code></pre>

<p>Если бы <code>operator+=</code> возвращал новый объект (<code>List</code>) вместо ссылки (<code>List&amp;</code>),
то при вызове <code>+= "three"</code> менялось содержимое не <code>x</code>, а этого нового объекта и результат был бы <code>onetwo</code>.</p>
<p>Можно определить оператор <code>+</code> через <code>+=</code> и конструктор копирования:</p>
<pre><code>List&amp; operator+=(const List &amp; other) {
    for (List::iterator it = other.begin(); it != other.end(); ++it) {
        this-&gt;push_back(*it);
    }
    return *this;
}

List operator+(const List &amp; other) const {
    List result(*this); // создаём копию &quot;этого&quot; списка
    result += other; // добавляем к копии &quot;другой&quot; список
    return result; // возвращаем результат
}
</code></pre>

<p><strong>Сравнение итераторов.</strong> В коде часто встречается конструкция <code>it != list.end()</code>.
Как правильно сравнить два итератора?
Во-первых, нужно помнить, что итераторы можно копировать.
Во-вторых, что значит "два итератора равны"?
В случае со списком это означает, что два итератора указывают на один и тот-же узел.
Как понять, что итераторы указывают на один и тот же узел?
Использовать "хитрый хак" - сравнить два указателя :)</p>
<pre><code>bool operator==(const iterator &amp; other) const {
    return this-&gt;node == other.node;
}
bool operator!=(const iterator &amp; other) const {
    return !((*this) == other);
}
</code></pre>

<p>Как узнать, что <code>iterator++</code> дошел до конца списка?
Если внутри итератора хранить длину списка и позицию, как в классе <a href="../seminar2/">Str</a>,
но для связного списка это не будет работать.
Например:</p>
<pre><code class="C++">struct iterator {
    Node * node;
    int len;
    int pos;
};

int main() {
    List l{1, 2};
    List::iterator it = l.begin();
    l.push_back(3);
    cout &lt;&lt; *it &lt;&lt; endl; // 1
    ++it;
    cout &lt;&lt; *it &lt;&lt; endl; // 2
    ++it;
    cout &lt;&lt; *it &lt;&lt; endl; // Должно быть 3, но it не знает, что длина списка изменилась
}
</code></pre>

<p>Можно сказать "но я же могу использовать ссылку на длину, следующим образом:"</p>
<pre><code class="C++">class List {
    // ...
    int len
    // ...
};

struct iterator {
    Node * node;
    int &amp; len; // len указывает на List::len
    int pos;
};
</code></pre>

<p>но тогда я предложу следующий вариант, который всё испортит:</p>
<pre><code class="C++">int main() {
    List l{1, 2};
    List::iterator it = l.begin();
    l.push_front(0);
    l.pop_back();
    // Длина списка не изменилась, но изменилась относительная позиция
}
</code></pre>

<p>Вообще, самым лучшим решением будет не хранить длину списка (?!).
Как понять, что итератор дошёл до конца списка?
Очень просто: если у текущего узла нет следующего, значит это конец:</p>
<pre><code class="C++">struct iterator {
    Node * node;
};

iterator &amp; operator++() {
    if (this-&gt;node-&gt;next) {
        this-&gt;node = this-&gt;node-&gt;next;
    }
    return *this;
}
</code></pre>

<p><strong>Что возвращает метод end()?</strong>
Метод <code>end()</code> возвращает итератор, указывающий на фиктивный элемент (узел), являющийся <em>первый после последнего реального элемента в списке</em>.
Покажу на примере. Допустим, список содержит элементы 1, 2 и 3.
Тогда список будет выглядеть примерно следующим образом:</p>
<pre><code>        begin()                            end()
           |                                |
           V                                V
        iterator                          iterator
           |                                |
           V                                V
NULL  &lt;-  node  &lt;-&gt;  node  &lt;-&gt;  node  &lt;-&gt;  node -&gt; NULL
           |          |          |
           V          V          V
           1          2          3
</code></pre>

<p>В самом классе <code>List</code> достаточно иметь два поля: <code>Node * _begin</code> и <code>Node * _end</code>,
при этом <code>_end</code> всегда будет указывать на узел с "первым после последнего элементом",
а <code>_begin</code> - на узел с первым элементом.</p>
<p><strong>Как тогда должен выглядеть пустой список?</strong>
<code>_end</code> должен указывать на "фиктивный" узел, а <code>_begin</code> должен указывать на <code>_end</code>:</p>
<pre><code class="C++">class List {
    // ...
private:
    Node * _begin;
    Node * _end;
};

List::List() {
    _end = new Node();
    _begin = _end;
}
</code></pre>

<p>Не забывайте при добавлении и удалении узлов <strong>перестраивать указатели соседних узлов</strong>.</p>
<p><strong>Нельзя возвращать ссылки</strong> (точно так же, как и указатели) <strong>на локальные переменные</strong>
из методов, функций.
Например, следующий код будет неправильным:</p>
<pre><code>int &amp; getReference() {
    int x = 13;
    return x;
}
</code></pre>

<p>Компилятор будет (должен) выдавать предупреждение для такого кода:</p>
<pre><code>В функции-члене «int&amp; getReference()»:
предупреждение: возвращена ссылка на локальную переменную «x» [-Wreturn-local-addr]
   int x = 13;
       ^
</code></pre>

<p>В следующем коде та же самая ошибка:</p>
<pre><code>class Node {
    // ...
public:
    value_type &amp; getValue();
    // ...
};

class List {
    // ...
public:
    value_type &amp; front() {
        value_type result = this-&gt;_begin-&gt;getValue(); // создаётся локальная переменная
        return result; // ошибка: возвращается ссылка на локальную переменную
    }
private:
    Node * _begin;
};
</code></pre>

<p>Использовать <em>статические переменные</em> для решения этой проблемы <strong>не нужно</strong>.
В данном случае можно написать просто:</p>
<pre><code>    value_type &amp; front() {
        return this-&gt;_begin-&gt;getValue();
    }
</code></pre>

<p>Или, если нужно использовать локальную переменную, то объявить её как ссылку:</p>
<pre><code>    value_type &amp; front() {
        value_type &amp; result = this-&gt;_begin-&gt;getValue();
        return result;
    }
</code></pre>

<p><strong>Из константного метода нельзя вызвать неконстантный метод.</strong>
Также нельзя вызвать неконстантный метод <em>поля</em> класса.
Объяснение простое: const-методы не должны изменять состояние объекта.
Поэтому следующий код работать не будет:</p>
<pre><code>class Node {
    // ...
public:
    value_type &amp; getValue();
    // ...
};

class List {
    // ...
public:
    const value_type &amp; front() const {
        return this-&gt;_begin-&gt;getVanue(); // ошибка: вывзов non-const метода из const
    }
private:
    Node * _begin;
};
</code></pre>

<p>В таком случае можно объявить два метода <code>getValue</code> - const и не-const:</p>
<pre><code>class Node {
    // ...
public:
    value_type &amp; getValue();
    const value_type &amp; getValue() const;
    // ...
};
</code></pre>

<p>Тогда из const-метода <code>front</code> будет вызвать const-метод <code>getValue</code>.
Этот подход используют коллекции из стандартной библиотеки, например метод
<a href="http://www.cplusplus.com/reference/vector/vector/operator%5B%5D/">operator[]</a> класса <em>std::vector</em>.
В случае, если от метода <code>getValue</code> требуется только доступ "на чтение", можно оставить только const-версию метода.</p>
<p><strong>Обн. 07.10.2015</strong>
Важно, чтобы <strong>код соответствовал спецификации</strong>.
В частности, <em>публичные</em> методы должны называться так, как указано в задании
и иметь точно такую же сигнатуру (если метод обозначен как <code>const</code>, то <code>const</code> убирать нельзя).
Самый простой способ этого добиться - полностью скопировать объявление класса <code>LinkedList</code>
из текста задания в заголовочный файл.
Константные итераторы традиционно называются <code>const_iterator</code>.</p>
<h2 id="_2">Пожелания</h2>
<p><strong>Структуры с стиле C</strong>. Вместо</p>
<pre><code class="C++">typedef struct _MyStruct {
    int some_field;
} MyStruct;
</code></pre>

<p>можно писать просто</p>
<pre><code class="C++">struct MyStruct {
    int some_field;
};
</code></pre>

<p>Поскольку ключевое слово <code>struct</code> так же, как слово <code>class</code>, определяет класс, но с доступом <code>public</code> к членам класса по-умолчанию, последняя запись аналогична:</p>
<pre><code class="C++">class MyStruct {
public:
    int some_field;
};
</code></pre>

<p><strong>Имена файлов</strong>.
Старайтесь придерживаться следующей схемы разбиения кода на модули (файлы).
Каждому классу с именем <code>SomeClass</code> должна соответствовать пара файлов
<code>SomeClass.h</code> и <code>SomeClass.cpp</code>.
Вложенные классы (например <code>SomeClass::iterator</code>) можно определять в тех же файлах.
функцию <code>main()</code> лучше всего располагать в отдельном файле <code>main.cpp</code>.
Тесты располагаются в отдельном файле (файлах), например: <code>SomeClass_test.cpp</code> - функции для тестирования класса <code>SomeClass</code>.</p>
<p>Таким образом, код первой задачи можно разбить на 4 файла:
<code>LinkedList.h</code>, <code>LinkedList.cpp</code>, <code>LinkedList_test.cpp</code> и <code>main.cpp</code>.</p>
<p><em>Продолжение следует</em></p></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
